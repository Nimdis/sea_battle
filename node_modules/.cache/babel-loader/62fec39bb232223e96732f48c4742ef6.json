{"ast":null,"code":"import { CellsStore, ECellType } from './CellsStore';\nconst MAX_COUNT_BY_SHIP_TYPE = {\n  4: 1,\n  3: 2,\n  2: 3,\n  1: 4\n};\n\nclass ShipManager {\n  constructor(cells) {\n    this.fieldCanvas = void 0;\n    this.currentShip = void 0;\n    this.prevShip = void 0;\n    this.fieldCanvas = new FieldCanvas(cells);\n  }\n\n  getCells() {\n    return this.fieldCanvas.getCells();\n  }\n\n  upsertShipByPosition(i, j) {\n    if (this.currentShip) {\n      return this.updateCurrentShipPostion(i, j);\n    }\n\n    this.createShipByPosition(i, j);\n  }\n\n  createShipByPosition(i, j) {\n    const shipDescr = {\n      num: 1,\n      position: {\n        i,\n        j\n      },\n      rotation: {\n        i: 1,\n        j: 0\n      },\n      size: 4\n    };\n\n    if (this.prevShip) {\n      if (MAX_COUNT_BY_SHIP_TYPE[this.prevShip.size] >= this.prevShip.num) {\n        shipDescr.size -= 1;\n        shipDescr.num = 1;\n        return;\n      } else {\n        shipDescr.num += 1;\n      }\n    }\n\n    this.currentShip = new Ship(shipDescr);\n    this.drawShip(this.currentShip);\n  }\n\n  deleteCurrentShip() {\n    this.currentShip = undefined;\n    this.fieldCanvas.cleanUpCells();\n  }\n\n  updateCurrentShipPostion(i, j) {\n    if (this.currentShip) {\n      this.currentShip.position = {\n        i,\n        j\n      };\n      this.drawShip(this.currentShip);\n    }\n  }\n\n  addShipByPostion(i, j) {\n    this.prevShip = this.currentShip;\n    this.createShipByPosition(i, j);\n    this.fieldCanvas.updateInitialCells();\n    this.drawShip(this.currentShip);\n  }\n\n  rotateCurrentShip() {\n    if (this.currentShip) {\n      this.currentShip.rotate();\n      this.drawShip(this.currentShip);\n    }\n  }\n\n  drawShip(ship) {\n    this.fieldCanvas.cleanUpCells();\n\n    if (!this.currentShip) {\n      return;\n    }\n\n    const {\n      size,\n      rotation,\n      position\n    } = this.currentShip;\n\n    if (!position) {\n      return;\n    }\n\n    const {\n      i,\n      j\n    } = position;\n    const shift = 0; //Math.floor((this.currentShip.size - 1)/2)\n\n    const minPoint = 0; //-shift\n\n    const maxPoint = size; //-shift\n\n    for (let k = minPoint; k < maxPoint; k++) {\n      const currentPoint = {\n        i: 0,\n        j: 0\n      };\n\n      if (k + rotation.i * i > 9 || k + rotation.j * j > 9) {\n        currentPoint.i = rotation.j * i + rotation.i * (9 - k + minPoint);\n        currentPoint.j = (9 - k + minPoint) * rotation.j + j * rotation.i;\n        this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip);\n      } else if (k + rotation.i < 0 || k + rotation.j < 0) {\n        currentPoint.i = i * rotation.j + rotation.i * (Math.abs(k) + maxPoint);\n        currentPoint.j = (Math.abs(k) + maxPoint) * rotation.j + rotation.i * j;\n        this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip);\n      } else {\n        currentPoint.i = i + k * rotation.i;\n        currentPoint.j = j + k * rotation.j;\n        this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip);\n      }\n    }\n  }\n\n}\n\nclass FieldCanvas extends CellsStore {\n  constructor(cells) {\n    super(cells);\n    this.initialCells = void 0;\n    this.initialCells = cells;\n  }\n\n  updateInitialCells() {\n    this.initialCells = this.getCells();\n  }\n\n  cleanUpCells() {\n    this.setCells(this.initialCells);\n  }\n\n}\n\nclass Ship {\n  constructor({\n    size,\n    position,\n    rotation,\n    num\n  }) {\n    this.position = void 0;\n    this.size = void 0;\n    this.rotation = void 0;\n    this.num = void 0;\n    this.size = size;\n    this.position = position;\n    this.rotation = rotation;\n    this.num = num;\n  }\n\n  rotate() {\n    this.rotation.i = 1 - this.rotation.i;\n    this.rotation.j = 1 - this.rotation.j;\n  }\n\n} // 1. Mouse in = create current ship + place it\n// 2. Move over = change current ship position + redraw\n// 3. Mouse leave = delete current ship\n\n\nexport class InitScreenStore {\n  constructor(cells) {\n    this.shipManager = void 0;\n    this.shipManager = new ShipManager(cells);\n  } // private testFree(filed: FieldStore, point: TPosition): boolean {\n  //     for (let i = point.i == 0 ? 0 : -1; i < 2 - Math.floor(point.i / 9); i++) {\n  //         for (let j = point.i == 0 ? 0 : -1; j < 2 - Math.floor(point.i / 9); j++) {\n  //             if (filed.getCell(point.i + i, point.j + j) == ECellType.withShip) {\n  //                 return true\n  //             }\n  //         }\n  //     }\n  //     return false\n  // }\n\n\n  getCells() {\n    return this.shipManager.getCells();\n  }\n\n  handleMouseOver(i, j) {\n    this.shipManager.upsertShipByPosition(i, j);\n  }\n\n  handleMouseLeave() {\n    this.shipManager.deleteCurrentShip();\n  }\n\n  handleClick(i, j) {\n    this.shipManager.addShipByPostion(i, j);\n  }\n\n  handleRotate() {\n    this.shipManager.rotateCurrentShip();\n  }\n\n}","map":{"version":3,"sources":["/home/anton/Рабочий стол/projects/sea_battle/src/entities/initScreen.ts"],"names":["CellsStore","ECellType","MAX_COUNT_BY_SHIP_TYPE","ShipManager","constructor","cells","fieldCanvas","currentShip","prevShip","FieldCanvas","getCells","upsertShipByPosition","i","j","updateCurrentShipPostion","createShipByPosition","shipDescr","num","position","rotation","size","Ship","drawShip","deleteCurrentShip","undefined","cleanUpCells","addShipByPostion","updateInitialCells","rotateCurrentShip","rotate","ship","shift","minPoint","maxPoint","k","currentPoint","setCell","withShip","Math","abs","initialCells","setCells","InitScreenStore","shipManager","handleMouseOver","handleMouseLeave","handleClick","handleRotate"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,SAArB,QAA8C,cAA9C;AAsBA,MAAMC,sBAAsB,GAAG;AAC3B,KAAG,CADwB;AAE3B,KAAG,CAFwB;AAG3B,KAAG,CAHwB;AAI3B,KAAG;AAJwB,CAA/B;;AAOA,MAAMC,WAAN,CAAkB;AAKdC,EAAAA,WAAW,CAACC,KAAD,EAAgB;AAAA,SAJnBC,WAImB;AAAA,SAHnBC,WAGmB;AAAA,SAFnBC,QAEmB;AACvB,SAAKF,WAAL,GAAmB,IAAIG,WAAJ,CAAgBJ,KAAhB,CAAnB;AACH;;AAEDK,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKJ,WAAL,CAAiBI,QAAjB,EAAP;AACH;;AAEDC,EAAAA,oBAAoB,CAACC,CAAD,EAAYC,CAAZ,EAAuB;AACvC,QAAI,KAAKN,WAAT,EAAsB;AAClB,aAAO,KAAKO,wBAAL,CAA8BF,CAA9B,EAAiCC,CAAjC,CAAP;AACH;;AACD,SAAKE,oBAAL,CAA0BH,CAA1B,EAA6BC,CAA7B;AACH;;AAEDE,EAAAA,oBAAoB,CAACH,CAAD,EAAYC,CAAZ,EAAuB;AACvC,UAAMG,SAAgB,GAAG;AACrBC,MAAAA,GAAG,EAAE,CADgB;AAErBC,MAAAA,QAAQ,EAAE;AACNN,QAAAA,CADM;AACHC,QAAAA;AADG,OAFW;AAKrBM,MAAAA,QAAQ,EAAE;AACNP,QAAAA,CAAC,EAAE,CADG;AAENC,QAAAA,CAAC,EAAE;AAFG,OALW;AASrBO,MAAAA,IAAI,EAAE;AATe,KAAzB;;AAYA,QAAI,KAAKZ,QAAT,EAAmB;AACf,UAAIN,sBAAsB,CAAC,KAAKM,QAAL,CAAcY,IAAf,CAAtB,IAA8C,KAAKZ,QAAL,CAAcS,GAAhE,EAAqE;AACjED,QAAAA,SAAS,CAACI,IAAV,IAAkB,CAAlB;AACAJ,QAAAA,SAAS,CAACC,GAAV,GAAgB,CAAhB;AACA;AACH,OAJD,MAIO;AACHD,QAAAA,SAAS,CAACC,GAAV,IAAiB,CAAjB;AACH;AACJ;;AAED,SAAKV,WAAL,GAAmB,IAAIc,IAAJ,CAASL,SAAT,CAAnB;AACA,SAAKM,QAAL,CAAc,KAAKf,WAAnB;AACH;;AAEDgB,EAAAA,iBAAiB,GAAG;AAChB,SAAKhB,WAAL,GAAmBiB,SAAnB;AACA,SAAKlB,WAAL,CAAiBmB,YAAjB;AACH;;AAEDX,EAAAA,wBAAwB,CAACF,CAAD,EAAYC,CAAZ,EAAuB;AAC3C,QAAI,KAAKN,WAAT,EAAsB;AAClB,WAAKA,WAAL,CAAiBW,QAAjB,GAA4B;AAAEN,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAA5B;AACA,WAAKS,QAAL,CAAc,KAAKf,WAAnB;AACH;AACJ;;AAEDmB,EAAAA,gBAAgB,CAACd,CAAD,EAAYC,CAAZ,EAAuB;AACnC,SAAKL,QAAL,GAAgB,KAAKD,WAArB;AACA,SAAKQ,oBAAL,CAA0BH,CAA1B,EAA6BC,CAA7B;AACA,SAAKP,WAAL,CAAiBqB,kBAAjB;AACA,SAAKL,QAAL,CAAc,KAAKf,WAAnB;AACH;;AAEDqB,EAAAA,iBAAiB,GAAG;AAChB,QAAI,KAAKrB,WAAT,EAAsB;AAClB,WAAKA,WAAL,CAAiBsB,MAAjB;AACA,WAAKP,QAAL,CAAc,KAAKf,WAAnB;AACH;AACJ;;AAEOe,EAAAA,QAAR,CAAiBQ,IAAjB,EAA6B;AACzB,SAAKxB,WAAL,CAAiBmB,YAAjB;;AACA,QAAI,CAAC,KAAKlB,WAAV,EAAuB;AACnB;AACH;;AACD,UAAM;AAAEa,MAAAA,IAAF;AAAQD,MAAAA,QAAR;AAAkBD,MAAAA;AAAlB,QAA+B,KAAKX,WAA1C;;AACA,QAAI,CAACW,QAAL,EAAe;AACX;AACH;;AACD,UAAM;AAAEN,MAAAA,CAAF;AAAKC,MAAAA;AAAL,QAAWK,QAAjB;AACA,UAAMa,KAAa,GAAG,CAAtB,CAVyB,CAUF;;AACvB,UAAMC,QAAgB,GAAG,CAAzB,CAXyB,CAWC;;AAC1B,UAAMC,QAAgB,GAAGb,IAAzB,CAZyB,CAYI;;AAC7B,SAAK,IAAIc,CAAC,GAAGF,QAAb,EAAuBE,CAAC,GAAGD,QAA3B,EAAqCC,CAAC,EAAtC,EAA0C;AACtC,YAAMC,YAAuB,GAAG;AAC5BvB,QAAAA,CAAC,EAAE,CADyB;AAE5BC,QAAAA,CAAC,EAAE;AAFyB,OAAhC;;AAIA,UAAIqB,CAAC,GAAGf,QAAQ,CAACP,CAAT,GAAaA,CAAjB,GAAqB,CAArB,IAA0BsB,CAAC,GAAGf,QAAQ,CAACN,CAAT,GAAaA,CAAjB,GAAqB,CAAnD,EAAsD;AAClDsB,QAAAA,YAAY,CAACvB,CAAb,GAAiBO,QAAQ,CAACN,CAAT,GAAaD,CAAb,GAAiBO,QAAQ,CAACP,CAAT,IAAc,IAAIsB,CAAJ,GAAQF,QAAtB,CAAlC;AACAG,QAAAA,YAAY,CAACtB,CAAb,GAAiB,CAAC,IAAIqB,CAAJ,GAAQF,QAAT,IAAqBb,QAAQ,CAACN,CAA9B,GAAkCA,CAAC,GAAGM,QAAQ,CAACP,CAAhE;AACA,aAAKN,WAAL,CAAiB8B,OAAjB,CAAyBD,YAAY,CAACvB,CAAtC,EAAyCuB,YAAY,CAACtB,CAAtD,EAAyDZ,SAAS,CAACoC,QAAnE;AACH,OAJD,MAIO,IAAIH,CAAC,GAAGf,QAAQ,CAACP,CAAb,GAAiB,CAAjB,IAAsBsB,CAAC,GAAGf,QAAQ,CAACN,CAAb,GAAiB,CAA3C,EAA8C;AACjDsB,QAAAA,YAAY,CAACvB,CAAb,GAAiBA,CAAC,GAAGO,QAAQ,CAACN,CAAb,GAAiBM,QAAQ,CAACP,CAAT,IAAc0B,IAAI,CAACC,GAAL,CAASL,CAAT,IAAcD,QAA5B,CAAlC;AACAE,QAAAA,YAAY,CAACtB,CAAb,GAAiB,CAACyB,IAAI,CAACC,GAAL,CAASL,CAAT,IAAcD,QAAf,IAA2Bd,QAAQ,CAACN,CAApC,GAAwCM,QAAQ,CAACP,CAAT,GAAaC,CAAtE;AACA,aAAKP,WAAL,CAAiB8B,OAAjB,CAAyBD,YAAY,CAACvB,CAAtC,EAAyCuB,YAAY,CAACtB,CAAtD,EAAyDZ,SAAS,CAACoC,QAAnE;AACH,OAJM,MAIA;AACHF,QAAAA,YAAY,CAACvB,CAAb,GAAiBA,CAAC,GAAGsB,CAAC,GAAGf,QAAQ,CAACP,CAAlC;AACAuB,QAAAA,YAAY,CAACtB,CAAb,GAAiBA,CAAC,GAAGqB,CAAC,GAAGf,QAAQ,CAACN,CAAlC;AACA,aAAKP,WAAL,CAAiB8B,OAAjB,CAAyBD,YAAY,CAACvB,CAAtC,EAAyCuB,YAAY,CAACtB,CAAtD,EAAyDZ,SAAS,CAACoC,QAAnE;AACH;AACJ;AACJ;;AAzGa;;AA4GlB,MAAM5B,WAAN,SAA0BT,UAA1B,CAAqC;AAGjCI,EAAAA,WAAW,CAACC,KAAD,EAAgB;AACvB,UAAMA,KAAN;AADuB,SAF3BmC,YAE2B;AAEvB,SAAKA,YAAL,GAAoBnC,KAApB;AACH;;AAEDsB,EAAAA,kBAAkB,GAAG;AACjB,SAAKa,YAAL,GAAoB,KAAK9B,QAAL,EAApB;AACH;;AAEDe,EAAAA,YAAY,GAAG;AACX,SAAKgB,QAAL,CAAc,KAAKD,YAAnB;AACH;;AAdgC;;AAyBrC,MAAMnB,IAAN,CAAW;AAMPjB,EAAAA,WAAW,CAAC;AAAEgB,IAAAA,IAAF;AAAQF,IAAAA,QAAR;AAAkBC,IAAAA,QAAlB;AAA4BF,IAAAA;AAA5B,GAAD,EAA2C;AAAA,SALtDC,QAKsD;AAAA,SAJtDE,IAIsD;AAAA,SAHtDD,QAGsD;AAAA,SAFtDF,GAEsD;AAClD,SAAKG,IAAL,GAAYA,IAAZ;AACA,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKF,GAAL,GAAWA,GAAX;AACH;;AAEDY,EAAAA,MAAM,GAAG;AACL,SAAKV,QAAL,CAAcP,CAAd,GAAmB,IAAI,KAAKO,QAAL,CAAcP,CAArC;AACA,SAAKO,QAAL,CAAcN,CAAd,GAAmB,IAAI,KAAKM,QAAL,CAAcN,CAArC;AACH;;AAhBM,C,CAmBX;AACA;AACA;;;AAEA,OAAO,MAAM6B,eAAN,CAAsB;AAGzBtC,EAAAA,WAAW,CAACC,KAAD,EAAgB;AAAA,SAFnBsC,WAEmB;AACvB,SAAKA,WAAL,GAAmB,IAAIxC,WAAJ,CAAgBE,KAAhB,CAAnB;AACH,GALwB,CAOzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAK,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKiC,WAAL,CAAiBjC,QAAjB,EAAP;AACH;;AAEDkC,EAAAA,eAAe,CAAChC,CAAD,EAAYC,CAAZ,EAAuB;AAClC,SAAK8B,WAAL,CAAiBhC,oBAAjB,CAAsCC,CAAtC,EAAyCC,CAAzC;AACH;;AAEDgC,EAAAA,gBAAgB,GAAG;AACf,SAAKF,WAAL,CAAiBpB,iBAAjB;AACH;;AAEDuB,EAAAA,WAAW,CAAClC,CAAD,EAAYC,CAAZ,EAAuB;AAC9B,SAAK8B,WAAL,CAAiBjB,gBAAjB,CAAkCd,CAAlC,EAAqCC,CAArC;AACH;;AAEDkC,EAAAA,YAAY,GAAG;AACX,SAAKJ,WAAL,CAAiBf,iBAAjB;AACH;;AApCwB","sourcesContent":["import { CellsStore, ECellType, TCells } from './CellsStore'\n\nexport type TPosition = {\n    i: number\n    j: number\n}\n\ntype TRotationUnit = 0 | 1\n\ntype TRotation = {\n    i: TRotationUnit\n    j: TRotationUnit\n}\n\nexport type TShipSize = 1 | 2 | 3 | 4\n\nexport interface ICurrentShip {\n    position?: TPosition\n    size: TShipSize\n    rotation: TPosition\n}\n\nconst MAX_COUNT_BY_SHIP_TYPE = {\n    4: 1,\n    3: 2,\n    2: 3,\n    1: 4,\n}\n\nclass ShipManager {\n    private fieldCanvas: FieldCanvas\n    private currentShip?: Ship\n    private prevShip?: Ship\n\n    constructor(cells: TCells) {\n        this.fieldCanvas = new FieldCanvas(cells)\n    }\n\n    getCells() {\n        return this.fieldCanvas.getCells()\n    }\n\n    upsertShipByPosition(i: number, j: number) {\n        if (this.currentShip) {\n            return this.updateCurrentShipPostion(i, j)\n        }\n        this.createShipByPosition(i, j)\n    }\n\n    createShipByPosition(i: number, j: number) {\n        const shipDescr: IShip = {\n            num: 1,\n            position: {\n                i, j\n            },\n            rotation: {\n                i: 1,\n                j: 0\n            },\n            size: 4\n        };\n\n        if (this.prevShip) {\n            if (MAX_COUNT_BY_SHIP_TYPE[this.prevShip.size] >= this.prevShip.num) {\n                shipDescr.size -= 1\n                shipDescr.num = 1\n                return\n            } else {\n                shipDescr.num += 1\n            }\n        }\n\n        this.currentShip = new Ship(shipDescr)\n        this.drawShip(this.currentShip)\n    }\n\n    deleteCurrentShip() {\n        this.currentShip = undefined\n        this.fieldCanvas.cleanUpCells()\n    }\n\n    updateCurrentShipPostion(i: number, j: number) {\n        if (this.currentShip) {\n            this.currentShip.position = { i, j }\n            this.drawShip(this.currentShip)\n        }\n    }\n\n    addShipByPostion(i: number, j: number) {\n        this.prevShip = this.currentShip\n        this.createShipByPosition(i, j)\n        this.fieldCanvas.updateInitialCells()\n        this.drawShip(this.currentShip!)\n    }\n\n    rotateCurrentShip() {\n        if (this.currentShip) {\n            this.currentShip.rotate()\n            this.drawShip(this.currentShip)\n        }\n    }\n\n    private drawShip(ship: Ship) {\n        this.fieldCanvas.cleanUpCells()\n        if (!this.currentShip) {\n            return\n        }\n        const { size, rotation, position } = this.currentShip!\n        if (!position) {\n            return\n        }\n        const { i, j } = position;\n        const shift: number = 0//Math.floor((this.currentShip.size - 1)/2)\n        const minPoint: number = 0//-shift\n        const maxPoint: number = size//-shift\n        for (let k = minPoint; k < maxPoint; k++) {\n            const currentPoint: TPosition = {\n                i: 0,\n                j: 0\n            }\n            if (k + rotation.i * i > 9 || k + rotation.j * j > 9) {\n                currentPoint.i = rotation.j * i + rotation.i * (9 - k + minPoint)\n                currentPoint.j = (9 - k + minPoint) * rotation.j + j * rotation.i\n                this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip)\n            } else if (k + rotation.i < 0 || k + rotation.j < 0) {\n                currentPoint.i = i * rotation.j + rotation.i * (Math.abs(k) + maxPoint)\n                currentPoint.j = (Math.abs(k) + maxPoint) * rotation.j + rotation.i * j\n                this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip)\n            } else {\n                currentPoint.i = i + k * rotation.i\n                currentPoint.j = j + k * rotation.j\n                this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip)\n            }\n        }\n    }\n}\n\nclass FieldCanvas extends CellsStore {\n    initialCells: TCells\n\n    constructor(cells: TCells) {\n        super(cells)\n        this.initialCells = cells\n    }\n\n    updateInitialCells() {\n        this.initialCells = this.getCells()\n    }\n\n    cleanUpCells() {\n        this.setCells(this.initialCells)\n    }\n\n}\n\ninterface IShip {\n    size: TShipSize,\n    position: TPosition,\n    rotation: TRotation,\n    num: number\n}\n\nclass Ship {\n    position: TPosition\n    size: TShipSize\n    rotation: TRotation\n    num: number\n\n    constructor({ size, position, rotation, num }: IShip) {\n        this.size = size\n        this.position = position\n        this.rotation = rotation\n        this.num = num\n    }\n\n    rotate() {\n        this.rotation.i = (1 - this.rotation.i) as TRotationUnit\n        this.rotation.j = (1 - this.rotation.j) as TRotationUnit\n    }\n}\n\n// 1. Mouse in = create current ship + place it\n// 2. Move over = change current ship position + redraw\n// 3. Mouse leave = delete current ship\n\nexport class InitScreenStore {\n    private shipManager: ShipManager\n\n    constructor(cells: TCells) {\n        this.shipManager = new ShipManager(cells)\n    }\n\n    // private testFree(filed: FieldStore, point: TPosition): boolean {\n    //     for (let i = point.i == 0 ? 0 : -1; i < 2 - Math.floor(point.i / 9); i++) {\n    //         for (let j = point.i == 0 ? 0 : -1; j < 2 - Math.floor(point.i / 9); j++) {\n    //             if (filed.getCell(point.i + i, point.j + j) == ECellType.withShip) {\n    //                 return true\n    //             }\n    //         }\n    //     }\n    //     return false\n    // }\n\n    getCells() {\n        return this.shipManager.getCells()\n    }\n\n    handleMouseOver(i: number, j: number) {\n        this.shipManager.upsertShipByPosition(i, j)\n    }\n\n    handleMouseLeave() {\n        this.shipManager.deleteCurrentShip()\n    }\n\n    handleClick(i: number, j: number) {\n        this.shipManager.addShipByPostion(i, j)\n    }\n\n    handleRotate() {\n        this.shipManager.rotateCurrentShip()\n    }\n}"]},"metadata":{},"sourceType":"module"}