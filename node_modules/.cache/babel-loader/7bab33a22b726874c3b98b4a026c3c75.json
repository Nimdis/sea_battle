{"ast":null,"code":"import { CellsStore, ECellType } from './CellsStore';\nimport { cloneDeep } from \"lodash\";\nconst MAX_COUNT_BY_SHIP_TYPE = {\n  4: 1,\n  3: 2,\n  2: 3,\n  1: 4\n};\n\nclass ShipManager {\n  constructor(cells) {\n    this.fieldCanvas = void 0;\n    this.currentShip = void 0;\n    this.prevShip = void 0;\n    this.fieldCanvas = new FieldCanvas(cells);\n  }\n\n  getCells() {\n    return this.fieldCanvas.getCells();\n  }\n\n  upsertShipByPosition(i, j) {\n    if (this.currentShip) {\n      return this.updateCurrentShipPostion(i, j);\n    }\n\n    this.createShipByPosition(i, j);\n  }\n\n  createShipByPosition(i, j) {\n    const shipDescr = {\n      num: this.prevShip ? this.prevShip.num : 1,\n      position: {\n        i,\n        j\n      },\n      rotation: {\n        i: 1,\n        j: 0\n      },\n      size: this.prevShip ? this.prevShip.size : 4\n    };\n\n    if (this.prevShip) {\n      if (MAX_COUNT_BY_SHIP_TYPE[this.prevShip.size] == this.prevShip.num) {\n        shipDescr.size -= 1;\n        shipDescr.num = 1; //return\n      } else {\n        shipDescr.num += 1;\n      }\n    }\n\n    console.log(shipDescr.size);\n    this.currentShip = new Ship(shipDescr); //this.drawShip(this.currentShip)\n  }\n\n  deleteCurrentShip() {\n    if (this.currentShip) {\n      this.currentShip.position = undefined;\n    }\n\n    this.fieldCanvas.cleanUpCells();\n  }\n\n  updateCurrentShipPostion(i, j) {\n    if (this.currentShip) {\n      this.currentShip.position = {\n        i,\n        j\n      };\n      this.drawShip(this.currentShip);\n    }\n  }\n\n  addShipByPostion(i, j) {\n    if (this.currentShip.isCanPlace) {\n      this.prevShip = this.currentShip;\n      this.createShipByPosition(i, j);\n      this.fieldCanvas.updateInitialCells();\n      this.drawShip(this.currentShip);\n    }\n  }\n\n  rotateCurrentShip() {\n    if (this.currentShip) {\n      this.currentShip.rotate();\n      this.fieldCanvas.cleanUpCells();\n      this.drawShip(this.currentShip);\n    }\n  }\n\n  testFree(filed, i, j) {\n    for (let x = i == 0 ? 0 : -1; x < 2 - Math.floor(i / 9); x++) {\n      for (let y = i == 0 ? 0 : -1; y < 2 - Math.floor(i / 9); y++) {\n        if (filed[i + x][j + y] == ECellType.withShip) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  drawShip(ship) {\n    if (!this.currentShip) {\n      return;\n    }\n\n    const {\n      size,\n      rotation,\n      position\n    } = this.currentShip;\n\n    if (!position) {\n      return;\n    }\n\n    this.currentShip.isCanPlace = true;\n    const i = Math.max(position.i - Math.floor((size - 1) / 2) * rotation.i, 0);\n    const j = Math.max(position.j - Math.floor((size - 1) / 2) * rotation.j, 0);\n    const shift = Math.max(i * rotation.i + j * rotation.j + size - 10, 0);\n    const minPoint = 0 - shift;\n    const maxPoint = size - shift;\n\n    for (let k = minPoint; k < maxPoint; k++) {\n      const currentPoint = {\n        i: 0,\n        j: 0\n      };\n      currentPoint.i = i + k * rotation.i;\n      currentPoint.j = j + k * rotation.j;\n\n      if (this.testFree(this.fieldCanvas.initialCells, currentPoint.i, currentPoint.j)) {\n        this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip);\n      } else {\n        this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.hitted);\n        this.currentShip.isCanPlace = false;\n      }\n    }\n  }\n\n}\n\nclass FieldCanvas extends CellsStore {\n  constructor(cells) {\n    super(cells);\n    this.initialCells = void 0;\n    this.initialCells = cells;\n  }\n\n  updateInitialCells() {\n    this.initialCells = cloneDeep(this.getCells());\n  }\n\n  cleanUpCells() {\n    this.setCells(this.initialCells);\n  }\n\n}\n\nclass Ship {\n  constructor({\n    size,\n    position,\n    rotation,\n    num\n  }) {\n    this.position = void 0;\n    this.size = void 0;\n    this.rotation = void 0;\n    this.num = void 0;\n    this.isCanPlace = void 0;\n    this.size = size;\n    this.position = position;\n    this.rotation = rotation;\n    this.num = num;\n    this.isCanPlace = false;\n  }\n\n  rotate() {\n    this.rotation.i = 1 - this.rotation.i;\n    this.rotation.j = 1 - this.rotation.j;\n  }\n\n} // 1. Mouse in = create current ship + place it\n// 2. Move over = change current ship position + redraw\n// 3. Mouse leave = delete current ship\n\n\nexport class InitScreenStore {\n  constructor(cells) {\n    this.shipManager = void 0;\n    this.shipManager = new ShipManager(cells);\n  }\n\n  getCells() {\n    return this.shipManager.getCells();\n  }\n\n  handleMouseOver(i, j) {\n    this.shipManager.upsertShipByPosition(i, j);\n  }\n\n  handleMouseLeave() {\n    this.shipManager.deleteCurrentShip();\n  }\n\n  handleClick(i, j) {\n    this.shipManager.addShipByPostion(i, j);\n  }\n\n  handleRotate() {\n    this.shipManager.rotateCurrentShip();\n  }\n\n}","map":{"version":3,"sources":["/home/anton/Рабочий стол/projects/sea_battle/src/entities/initScreen.ts"],"names":["CellsStore","ECellType","cloneDeep","MAX_COUNT_BY_SHIP_TYPE","ShipManager","constructor","cells","fieldCanvas","currentShip","prevShip","FieldCanvas","getCells","upsertShipByPosition","i","j","updateCurrentShipPostion","createShipByPosition","shipDescr","num","position","rotation","size","console","log","Ship","deleteCurrentShip","undefined","cleanUpCells","drawShip","addShipByPostion","isCanPlace","updateInitialCells","rotateCurrentShip","rotate","testFree","filed","x","Math","floor","y","withShip","ship","max","shift","minPoint","maxPoint","k","currentPoint","initialCells","setCell","hitted","setCells","InitScreenStore","shipManager","handleMouseOver","handleMouseLeave","handleClick","handleRotate"],"mappings":"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","sourcesContent":["import { CellsStore, ECellType, TCells } from './CellsStore'\nimport { cloneDeep } from \"lodash\"\n\nexport type TPosition = {\n    i: number\n    j: number\n}\n\ntype TRotationUnit = 0 | 1\n\ntype TRotation = {\n    i: TRotationUnit\n    j: TRotationUnit\n}\n\nexport type TShipSize = 1 | 2 | 3 | 4\n\nexport interface ICurrentShip {\n    position?: TPosition\n    size: TShipSize\n    rotation: TPosition\n}\n\nconst MAX_COUNT_BY_SHIP_TYPE = {\n    4: 1,\n    3: 2,\n    2: 3,\n    1: 4,\n}\n\nclass ShipManager {\n    private fieldCanvas: FieldCanvas\n    private currentShip?: Ship\n    private prevShip?: Ship\n\n    constructor(cells: TCells) {\n        this.fieldCanvas = new FieldCanvas(cells)\n    }\n\n    getCells() {\n        return this.fieldCanvas.getCells()\n    }\n\n    upsertShipByPosition(i: number, j: number) {\n        if (this.currentShip) {\n            return this.updateCurrentShipPostion(i, j)\n        }\n        this.createShipByPosition(i, j)\n    }\n\n    createShipByPosition(i: number, j: number) {\n        const shipDescr: IShip = {\n            num: this.prevShip ? this.prevShip.num : 1,\n            position: {\n                i, j\n            },\n            rotation: {\n                i: 1,\n                j: 0\n            },\n            size: this.prevShip ? this.prevShip.size : 4\n        };\n\n        if (this.prevShip) {\n            if (MAX_COUNT_BY_SHIP_TYPE[this.prevShip.size] == this.prevShip.num) {\n                shipDescr.size -= 1\n                shipDescr.num = 1\n                //return\n            } else {\n                shipDescr.num += 1\n            }\n        }\n        console.log(shipDescr.size)\n        this.currentShip = new Ship(shipDescr)\n        //this.drawShip(this.currentShip)\n    }\n\n    deleteCurrentShip() {\n        if(this.currentShip){\n            this.currentShip.position = undefined\n        }\n        this.fieldCanvas.cleanUpCells()\n    }\n\n    updateCurrentShipPostion(i: number, j: number) {\n        if (this.currentShip) {\n            this.currentShip.position = { i, j }\n            this.drawShip(this.currentShip)\n        }\n    }\n\n    addShipByPostion(i: number, j: number) {\n        if(this.currentShip.isCanPlace){\n            this.prevShip = this.currentShip\n            this.createShipByPosition(i, j)\n            this.fieldCanvas.updateInitialCells()\n            this.drawShip(this.currentShip!)\n        }\n    }\n\n    rotateCurrentShip() {\n        if (this.currentShip) {\n            this.currentShip.rotate()\n            this.fieldCanvas.cleanUpCells()\n            this.drawShip(this.currentShip)\n        }\n    }\n\n    private testFree(filed: TCells, i: number, j: number): boolean {\n        for (let x = i == 0 ? 0 : -1; x < 2 - Math.floor(i / 9); x++) {\n            for (let y = i == 0 ? 0 : -1; y < 2 - Math.floor(i / 9); y++) {\n                if (filed[i + x][j + y] == ECellType.withShip) {\n                    return false\n                }\n            }\n        }\n        return true\n    }\n\n    private drawShip(ship: Ship) {\n        if (!this.currentShip) {\n            return\n        }\n        const { size, rotation, position } = this.currentShip!\n        if (!position) {\n            return\n        }\n        this.currentShip.isCanPlace = true\n        const i: number = Math.max(position.i - Math.floor((size - 1) / 2) * rotation.i, 0);\n        const j: number = Math.max(position.j - Math.floor((size - 1) / 2) * rotation.j, 0);\n        const shift: number = Math.max((i*rotation.i+j*rotation.j)+size-10, 0)\n        const minPoint: number = 0-shift\n        const maxPoint: number = size-shift\n        for (let k = minPoint; k < maxPoint; k++) {\n            const currentPoint: TPosition = {\n                i: 0,\n                j: 0\n            }\n            currentPoint.i = i + k * rotation.i\n            currentPoint.j = j + k * rotation.j\n            if(this.testFree(this.fieldCanvas.initialCells, currentPoint.i, currentPoint.j)){\n                this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.withShip)\n            }else{\n                this.fieldCanvas.setCell(currentPoint.i, currentPoint.j, ECellType.hitted)\n                this.currentShip.isCanPlace = false\n            }\n        }\n    }\n}\n\nclass FieldCanvas extends CellsStore {\n    initialCells: TCells\n\n    constructor(cells: TCells) {\n        super(cells)\n        this.initialCells = cells\n    }\n\n    updateInitialCells() {\n        this.initialCells = cloneDeep(this.getCells())\n    }\n\n    cleanUpCells() {\n        this.setCells(this.initialCells)\n    }\n\n}\n\ninterface IShip {\n    size: TShipSize,\n    position?: TPosition,\n    rotation: TRotation,\n    num: number\n}\n\nclass Ship {\n    position?: TPosition\n    size: TShipSize\n    rotation: TRotation\n    num: number\n    isCanPlace: boolean\n\n    constructor({ size, position, rotation, num }: IShip) {\n        this.size = size\n        this.position = position\n        this.rotation = rotation\n        this.num = num\n        this.isCanPlace = false\n    }\n\n    rotate() {\n        this.rotation.i = (1 - this.rotation.i) as TRotationUnit\n        this.rotation.j = (1 - this.rotation.j) as TRotationUnit\n    }\n}\n\n// 1. Mouse in = create current ship + place it\n// 2. Move over = change current ship position + redraw\n// 3. Mouse leave = delete current ship\n\nexport class InitScreenStore {\n    private shipManager: ShipManager\n\n    constructor(cells: TCells) {\n        this.shipManager = new ShipManager(cells)\n    }\n\n\n    getCells() {\n        return this.shipManager.getCells()\n    }\n\n    handleMouseOver(i: number, j: number) {\n        this.shipManager.upsertShipByPosition(i, j)\n    }\n\n    handleMouseLeave() {\n        this.shipManager.deleteCurrentShip()\n    }\n\n    handleClick(i: number, j: number) {\n        this.shipManager.addShipByPostion(i, j)\n    }\n\n    handleRotate() {\n        this.shipManager.rotateCurrentShip()\n    }\n}"]},"metadata":{},"sourceType":"module"}